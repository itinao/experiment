<script id="vs" type="x-shader/x-vertex">
attribute vec3 position;
attribute vec2 textureCoord;
varying   vec2 vTextureCoord;

void main(void){
    vTextureCoord = textureCoord;
    gl_Position   = vec4(position, 1.0);
}
</script>
<script id="fs" type="x-shader/x-fragment">
precision mediump float;

uniform sampler2D texture;
varying vec2      vTextureCoord;

uniform vec2 vScreenSize;
uniform vec2 vCenter;
uniform float fRadius;
uniform float fUzuStrength;

void main(void){
    vec2 pos = (vTextureCoord * vScreenSize) - vCenter;
    if (length(pos) >= fRadius) {
      gl_FragColor = texture2D(texture, vTextureCoord);
      return;
    }
    float len = length(vec3(pos.x, pos.y, 0.0));
    float uzu = min(max(1.0 - (len / fRadius), 0.0), 1.0)  * fUzuStrength;

    float x = pos.x * cos(uzu) - pos.y * sin(uzu); // x位置を回転
    float y = pos.x * sin(uzu) + pos.y * cos(uzu); // y位置を回転

    vec2 retPos = (vec2(x, y) + vCenter)  / vScreenSize;
    vec4 smpColor = texture2D(texture, retPos);
    gl_FragColor  = smpColor;
}
</script>

<template id="gl-uzu">
  <canvas id="c"></canvas>
  <script>
  </script>
</template>
 
<script src="js/class.js"></script>
<script src="js/gli.js"></script>
<script>
var GlUzu = Gli.extend({
  position: [
    -1.0,  1.0,  0.0,
     1.0,  1.0,  0.0,
    -1.0, -1.0,  0.0,
     1.0, -1.0,  0.0
  ],
  textureCoord: [
    0.0, 0.0,
    1.0, 0.0,
    0.0, 1.0,
    1.0, 1.0
  ],
  index: [
    0, 1, 2,
    1, 2, 3
  ],
  screenSize: [256, 256],
  center: [128, 128],
  radius: 500.0,
  uzuStrength: 100.0,
  init: function (c, doc) {
    this._super(c, doc);
    this.setFunc = function() {
        var gl = this.gl;
        var prg = this.prg;

        var attLocation = new Array();
        attLocation[0] = gl.getAttribLocation(prg, 'position');
        attLocation[1] = gl.getAttribLocation(prg, 'textureCoord');
 
        var attStride = new Array();
        attStride[0] = 3;
        attStride[1] = 2;
 

        var position = this.position;
        var textureCoord = this.textureCoord;
        var index = this.index;
    
        // vboとiboの生成
        var vPosition     = this.createVbo(position);
        var vTextureCoord = this.createVbo(textureCoord);
        var VBOList       = [vPosition, vTextureCoord];
        var iIndex        = this.createIbo(index);
    
        // VBOとIBOの登録
        this.setAttribute(VBOList, attLocation, attStride);

//
gl.uniform2fv(gl.getUniformLocation(prg, 'vScreenSize'), this.screenSize);
gl.uniform2fv(gl.getUniformLocation(prg, 'vCenter'), this.center);
gl.uniform1f(gl.getUniformLocation(prg, 'fRadius'), this.radius);
gl.uniform1f(gl.getUniformLocation(prg, 'fUzuStrength'), this.uzuStrength);
//

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iIndex);
    };
    this.renderFunc = function() {
        var index = this.index;
        var gl = this.gl;

var prg = this.prg;
this.radius = (this.radius - 1) <= 0 ? 0 : this.radius - 1;
this.uzuStrength = (this.uzuStrength - 1) <= 0 ? 0 : this.uzuStrength - 1;
gl.uniform2fv(gl.getUniformLocation(prg, 'vScreenSize'), this.screenSize);
gl.uniform2fv(gl.getUniformLocation(prg, 'vCenter'), this.center);
gl.uniform1f(gl.getUniformLocation(prg, 'fRadius'), this.radius);
gl.uniform1f(gl.getUniformLocation(prg, 'fUzuStrength'), this.uzuStrength);

        this.createTexture("img/fctokyo01c.jpg", function(texture) {
            // テクスチャをバインドする
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.drawElements(gl.TRIANGLES, index.length, gl.UNSIGNED_SHORT, 0);
        }.bind(this));
    };
  }
});
</script>

<script>
(function() {
  var currentScript = document._currentScript || document.currentScript;
  var doc = currentScript.ownerDocument;

  var prototype = Object.create(HTMLElement.prototype, {
    createdCallback: {
      value: function() {
        console.log("createdCallback");

        var width = this.getAttribute("width");
        var height = this.getAttribute("height");
        var src = this.getAttribute("src");

        var t = doc.querySelector('#gl-uzu');
        var clone = doc.importNode(t.content, true);


        // appendChildの前じゃないとcloneした要素が取れない
        var c = clone.getElementById("c");
        c.width = width;
        c.height = height;

        this.createShadowRoot().appendChild(clone);

        // appendChildの後じゃないとgetContextでcontextが取得できない
        moge = new GlUzu(c, doc);
        moge.setRenderParam();
var render = function(){
    moge.render();
    window.requestAnimationFrame(render);
};
render();
      }
    },
    attachedCallback: {
      value: function() {
        console.log("attachedCallback");
      }
    },
    detachedCallback: {
      value: function() {
        console.log("detachedCallback");
      }
    },
    attributeChangedCallback: {
      value: function() {
        console.log("attributeChangedCallback");
      }
    }
  });

  document.registerElement('gl-uzu', {prototype: prototype});
})();
</script>
